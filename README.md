# Learn Django 3.0
Following the [Guide](https://docs.djangoproject.com/en/3.0/)

### Setup Env

Prerequisite

* pipenv
* asdf

```
$ virtualenv python_env
```

```
$ source env_python/bin/activate
```

### Install Django

```
$ python -m pip install Django
```

```
$ python -m django --version
3.0.4
```

### Tutorial 01

[Creating a project](https://docs.djangoproject.com/en/3.0/intro/tutorial01/)

```
$ django-admin startproject mysite
```

Run server on a specific port

```
$ python manage.py runserver 8080
```

Migrate the database
```
$ python manage.py migrate
```

### Polls app

[Creating the polls app](https://docs.djangoproject.com/en/3.0/intro/tutorial01/#creating-the-polls-app)

```
$ python manage.py startapp polls
```

* Add a view [polls/views.py](/mysite/polls/views.py)
* Add url to [polls/urls.py](/mysite/polls/urls.py)
* Add app polls to mysite [mysite/urls.py](/mysite/mysite/urls.py)
* Add app polls to mysite [mysite/urls.py](/mysite/mysite/urls.py)

Verify
```
$ python manage.py runserver
```

Visit [http://localhost:8000/polls/](http://localhost:8000/polls/)

### Tutorial 02

[Creating models](https://docs.djangoproject.com/en/3.0/intro/tutorial02/#creating-models)

> Django follows the DRY Principle. The goal is to define your data model in one place and automatically derive things from it.

> This includes the migrations - unlike in Ruby On Rails, for example, migrations are entirely derived from your models file,
  and are essentially a history that Django can roll through to update your database schema to match your current models.

Create Migration of the polls model

```
$ python manage.py makemigrations polls
```

See SQL generated by migration

```
$ python manage.py sqlmigrate polls 0001
```

Migrate the model

```
python manage.py migrate
```
> The migrate command takes all the migrations that haven’t been applied (Django tracks which ones are applied using a special table
  in your database called django_migrations) and runs them against your database - essentially, synchronizing the changes you made
  to your models with the schema in the database.

### Playing with the api

[Playing with the api](https://docs.djangoproject.com/en/3.0/intro/tutorial02/#playing-with-the-api)

```
$ python manage.py shell
```

```
>>> from polls.models import Choice, Question  # Import the model classes we just wrote.

# No questions are in the system yet.
>>> Question.objects.all()

# Create a new Question.
# Support for time zones is enabled in the default settings file, so
# Django expects a datetime with tzinfo for pub_date. Use timezone.now()
# instead of datetime.datetime.now() and it will do the right thing.
>>> from django.utils import timezone
>>> q = Question(question_text="What's new?", pub_date=timezone.now())

# Save the object into the database. You have to call save() explicitly.
>>> q.save()

# Now it has an ID.
>>> q.id

# Access model field values via Python attributes.
>>> q.question_text
>>> q.pub_date

# Change values by changing the attributes, then calling save().
>>> q.question_text = "What's up?"
>>> q.save()

# objects.all() displays all the questions in the database.
>>> Question.objects.all()
```

### __str__()

> Wait a minute. <Question: Question object (1)> isn’t a helpful representation of this object.

```
>>> Question.objects.all()
<QuerySet [<Question: Question object (1)>]>
```

> adding a __str__() method to both Question and Choice

```
from django.db import models

class Question(models.Model):
    # ...
    def __str__(self):
        return self.question_text

class Choice(models.Model):
    # ...
    def __str__(self):
        return self.choice_text
```

### Custom method to model

In [polls/models](mysite/polls/models.py) add `was_published_recently`

```
import datetime

from django.db import models
from django.utils import timezone


class Question(models.Model):
    # ...
    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)
```

Starting `python manage.py shell`

```
# Django provides a rich database lookup API that's entirely driven by
# keyword arguments.
>>> Question.objects.filter(id=1)

>>> Question.objects.filter(question_text__startswith='What')

# Get the question that was published this year.
>>> from django.utils import timezone
>>> current_year = timezone.now().year
>>> Question.objects.get(pub_date__year=current_year)

# Request an ID that doesn't exist, this will raise an exception.
>>> Question.objects.get(id=2)
Traceback (most recent call last):
    ...
DoesNotExist: Question matching query does not exist.

# The following is identical to Question.objects.get(id=1).
>>> Question.objects.get(pk=1)

# Make sure our custom method worked.
>>> q = Question.objects.get(pk=1)
>>> q.was_published_recently()

# Give the Question a couple of Choices. The create call constructs a new
# Choice object, does the INSERT statement, adds the choice to the set
[# of available choices and returns the new Choice object. Django creates
# a set to hold the "other side" of a ForeignKey relation
# (e.g. a question's choice) which can be accessed via the API.
>>> q = Question.objects.get(pk=1)

# Display any choices from the related object set -- none so far.
>>> q.choice_set.all()

# Create three choices.
>>> q.choice_set.create(choice_text='Not much', votes=0)
>>> q.choice_set.create(choice_text='The sky', votes=0)
>>> c = q.choice_set.create(choice_text='Just hacking again', votes=0)

# Choice objects have API access to their related Question objects.
>>> c.question

# And vice versa: Question objects get access to Choice objects.
>>> q.choice_set.all()
>>> q.choice_set.count()

# The API automatically follows relationships as far as you need.
# Use double underscores to separate relationships.
# This works as many levels deep as you want; there's no limit.
# Find all Choices for any question whose pub_date is in this year
# (reusing the 'current_year' variable we created above).
>>> Choice.objects.filter(question__pub_date__year=current_year)

# Let's delete one of the choices. Use delete() for that.
>>> c = q.choice_set.filter(choice_text__startswith='Just hacking')
>>> c.delete()
```

### Django Admin

[Introducing Django Admin](https://docs.djangoproject.com/en/3.0/intro/tutorial02/#introducing-the-django-admin)

Creating an admin user

```
$ python manage.py createsuperuser
```

Start the development server

```
$ python manage.py runserver
```

Visit [Django Administration](http://127.0.0.1:8000/admin/)
